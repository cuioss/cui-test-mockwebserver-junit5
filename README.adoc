= cui-test-mockwebserver-junit5

== Status

image:https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml/badge.svg[Java CI with Maven,link=https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml]
image:http://img.shields.io/:license-apache-blue.svg[License,link=http://www.apache.org/licenses/LICENSE-2.0.html]
image:https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5/badge.svg[Maven Central,link=https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5]

https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5[image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=alert_status[Quality
Gate Status]]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=ncloc[Lines of Code,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=coverage[Coverage,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]


https://cuioss.github.io/cui-test-mockwebserver-junit5/about.html[Generated Documentation on github-pages]

== What is it?

A junit 5 extension for link:https://github.com/square/okhttp/tree/master/mockwebserver[MockWebServer]
 providing some convenience,
compared to the original.

=== Maven Coordinates

[source,xml]
----
    <dependency>
        <groupId>de.cuioss.test</groupId>
        <artifactId>cui-test-mockwebserver-junit5</artifactId>
    </dependency>
----

== Using MockWebServer

=== Basic usage with Parameter Injection

The recommended approach is to use parameter injection rather than implementing the MockWebServerHolder interface:

[source,java]
----
@EnableMockWebServer
class ParameterResolverTest {

    @Test
    @DisplayName("Should inject MockWebServer instance")
    void shouldInjectMockWebServer(MockWebServer server) {
        assertNotNull(server);
        assertTrue(server.getStarted());
    }

    @Test
    @DisplayName("Should inject URIBuilder")
    void shouldInjectUriBuilder(URIBuilder uriBuilder) {
        assertNotNull(uriBuilder);
        assertEquals("http", uriBuilder.build().getScheme());
        assertEquals("/", uriBuilder.getPath());
    }

    @Test
    @DisplayName("Should inject multiple parameters")
    void shouldInjectMultipleParameters(MockWebServer server, URIBuilder uriBuilder) {
        assertNotNull(server);
        assertTrue(server.getPort() > 0);
        assertEquals(server.getPort(), uriBuilder.getPort());
    }
}
----

=== Dispatching Requests

The recommended approach is to set up the dispatcher directly in your test method:

[source,java]
----
@EnableMockWebServer
class EndpointDispatcherTest {
    
    @Test
    void testWithEndpointDispatcher(MockWebServer server, URIBuilder uriBuilder) throws Exception {
        // Create an EndpointAnswerHandler for this test
        var handler = new EndpointAnswerHandler();
        
        // Configure endpoint responses
        handler.addAnswerFor("/api/data", new MockResponse.Builder()
            .addHeader("Content-Type", "application/json")
            .body("{'data': 'test'}")
            .code(HttpServletResponse.SC_OK)
            .build());
        
        // Set the dispatcher for this test
        server.setDispatcher(handler);
        
        // Create HttpClient
        HttpClient client = HttpClient.newHttpClient();
        
        // Create request using the URIBuilder parameter
        HttpRequest request = HttpRequest.newBuilder()
            .uri(uriBuilder.addPathSegment("api").addPathSegment("data").build())
            .GET()
            .build();
            
        // Send request and verify response
        HttpResponse<String> response = client.send(request, 
            HttpResponse.BodyHandlers.ofString());
        assertEquals(200, response.statusCode());
        assertEquals("{'data': 'test'}", response.body());
    }
}
----

=== ModuleDispatcherElement

`ModuleDispatcherElement` enables reusable request handling in `EnableMockWebServer` contexts. It returns an `Optional<MockResponse>` for matching requests.

Example JWKS endpoint dispatcher:

[source,java]
----
/**
 * Handles JWKS file resolution from the mock OAuth server, serving
 * "src/test/resources/token/test-public-key.jwks"
 */
public class JwksResolveDispatcher implements ModuleDispatcherElement {

    /** "/oidc/jwks.json" */
    public static final String LOCAL_PATH = "/oidc/jwks.json";

    @Getter
    @Setter
    private int callCounter = 0;

    @Override
    public Optional<MockResponse> handleGet(@NonNull RecordedRequest request) {
        callCounter++;
        return Optional.of(new MockResponse().addHeader("Content-Type", "application/json")
                .setBody(FileLoaderUtility
                        .toStringUnchecked(FileLoaderUtility.getLoaderForPath(PUBLIC_KEY_JWKS)))
                .setResponseCode(SC_OK));
    }

    @Override
    public String getBaseUrl() {
        return LOCAL_PATH;
    }

    /**
     * Verifies request count
     *
     * @param expected Expected number of requests
     */
    public void assertCallsAnswered(int expected) {
        assertEquals(expected, callCounter);
    }
}
----

Implementation example:

[source,java]
----
@EnableAutoWeld
@EnablePortalConfiguration
@EnableMockWebServer
class TokenParserProducerTest implements ShouldBeNotNull<TokenParserProducer>, MockWebServerHolder {

    @Setter
    private MockWebServer mockWebServer;

    protected int mockserverPort;

    private JwksResolveDispatcher jwksResolveDispatcher = new JwksResolveDispatcher();

    @Getter
    private final CombinedDispatcher dispatcher = new CombinedDispatcher().addDispatcher(jwksResolveDispatcher);

    @BeforeEach
    void setupMockServer() {
        mockserverPort = mockWebServer.getPort();
        configuration.put(VERIFY_SIGNATURE_JWKS_URL,
                "http://localhost:" + mockserverPort + jwksResolveDispatcher.getBaseUrl());
        configuration.update(VERIFY_SIGNATURE_ISSUER, TestTokenProducer.ISSUER);
        configuration.update(VERIFY_SIGNATURE_REFRESH_INTERVAL, "60");
        jwksResolveDispatcher.setCallCounter(0);
    }

    @Test
    void shouldCacheMultipleCalls() {
        jwksResolveDispatcher.assertCallsAnswered(0);
        String token = validSignedJWTWithClaims(PATIENT_ACCESS_TOKEN);
        JWTParser parser = parserProvider.get();

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        // Note: Initial implementation results in 2 calls instead of 1
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);
    }
}
----

=== Parameter Injection

MockWebServerExtension implements ParameterResolver, allowing direct injection of MockWebServer and related parameters into test methods. This is the recommended approach for accessing the server and related components.

[source,java]
----
@EnableMockWebServer
class ParameterResolverTest {

    @Test
    @DisplayName("Should inject multiple parameters")
    void shouldInjectMultipleParameters(MockWebServer server, URIBuilder uriBuilder) {
        // Multiple parameters can be injected
        assertNotNull(server);
        assertTrue(server.getPort() > 0);
        assertEquals(server.getPort(), uriBuilder.getPort());
        
        // Set up a dispatcher for this test
        server.setDispatcher(new Dispatcher() {
            @Override
            public MockResponse dispatch(RecordedRequest request) {
                if ("/api/test".equals(request.getPath())) {
                    return new MockResponse.Builder()
                        .addHeader("Content-Type", "text/plain")
                        .body("Hello World")
                        .code(HttpServletResponse.SC_OK)
                        .build();
                }
                return new MockResponse.Builder()
                    .code(HttpServletResponse.SC_NOT_FOUND)
                    .build();
            }
        });
    }
}
----

Supported parameter types:
* `MockWebServer` - The server instance
* `URIBuilder` - A builder for constructing request URIs
* `SSLContext` - The SSL context for HTTPS connections (when HTTPS is enabled)

=== HTTPS Support

When HTTPS is enabled, the extension automatically makes the SSLContext available for parameter injection, simplifying HTTPS testing:

[source,java]
----
/**
 * Demonstrates how to access a MockWebServer with HTTPS using Java's HttpClient.
 *
 * <p>This test shows how to configure Java's HttpClient to trust certificates provided by the extension.
 * The key to making HTTPS work with self-signed certificates is to use the same certificate material
 * for both the server and client.</p>
 */
@EnableMockWebServer(
        useHttps = true
)
@DisplayName("HttpClient HTTPS Test")
class ExtensionProvidedHttpsTest {

    /**
     * Tests a basic HTTPS connection to a default endpoint.
     * The SSLContext is directly injected as a parameter using the parameter resolving feature.
     */
    @Test
    @DisplayName("Should successfully connect to HTTPS server with extension-provided certificate")
    void shouldConnectToHttpsServer(URIBuilder serverURIBuilder, SSLContext sslContext) throws IOException, InterruptedException {
        // Arrange
        assertNotNull(sslContext, "SSLContext should be injected as a parameter");
        assertNotNull(serverURIBuilder, "URL builder should be injected as a parameter");

        // Verify the URL builder creates HTTPS URLs
        URI uri = serverURIBuilder.build();
        assertEquals("https", uri.getScheme(), "Server URL should use HTTPS");

        // Configure HttpClient with the injected SSLContext
        HttpClient client = HttpClient.newBuilder()
                .sslContext(sslContext)
                .connectTimeout(Duration.ofSeconds(10))
                .build();

        // Act: Make an HTTPS request using the URL builder
        HttpRequest request = HttpRequest.newBuilder()
                .uri(serverURIBuilder.addPathSegment("api").addPathSegment("test").build())
                .GET()
                .build();

        // Assert: Verify successful connection and response
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        assertEquals(200, response.statusCode(), "Should receive 200 OK response");
    }
}
----

HTTPS configuration options:
* `useHttps` - Enable HTTPS support (default: false)
* `keyMaterialProviderIsSelfSigned` - Use auto-generated self-signed certificates (default: false)
* `keyMaterialProviderIsTestClass` - Use custom certificates provided by the test class (default: false)
