= cui-test-mockwebserver-junit5

== Status

image:https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml/badge.svg[Java CI with Maven,link=https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml]
image:http://img.shields.io/:license-apache-blue.svg[License,link=http://www.apache.org/licenses/LICENSE-2.0.html]
image:https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5/badge.svg[Maven Central,link=https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5]

https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5[image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=alert_status[Quality
Gate Status]]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=ncloc[Lines of Code,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=coverage[Coverage,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]


https://cuioss.github.io/cui-test-mockwebserver-junit5/about.html[Generated Documentation on github-pages]

== What is it?

A junit 5 extension for link:https://github.com/square/okhttp/tree/master/mockwebserver[MockWebServer]
 providing some convenience,
compared to the original.

=== Maven Coordinates

[source,xml]
----
    <dependency>
        <groupId>de.cuioss.test</groupId>
        <artifactId>cui-test-mockwebserver-junit5</artifactId>
    </dependency>
----

== Using MockWebServer

=== Basic usage with Parameter Injection

The recommended approach is to use parameter injection rather than implementing the MockWebServerHolder interface:

[source,java]
----
@EnableMockWebServer
class ParameterResolverTest {

    @Test
    @DisplayName("Should inject MockWebServer instance")
    void shouldInjectMockWebServer(MockWebServer server) {
        assertNotNull(server);
        assertTrue(server.getStarted());
    }

    // Tests for port parameter resolver removed as it's redundant with URIBuilder

    @Test
    @DisplayName("Should inject URIBuilder")
    void shouldInjectUriBuilder(URIBuilder uriBuilder) {
        assertNotNull(uriBuilder);
        assertEquals("http", uriBuilder.build().getScheme());
        assertEquals("/", uriBuilder.getPath());
    }

    // Test for String parameter resolver removed as it's redundant with URIBuilder

    @Test
    @DisplayName("Should inject multiple parameters")
    void shouldInjectMultipleParameters(MockWebServer server, URIBuilder uriBuilder) {
        assertNotNull(server);
        assertTrue(server.getPort() > 0);
        assertEquals(server.getPort(), uriBuilder.getPort());
    }
}
----

=== Dispatching Requests

The recommended approach is to set up the dispatcher directly in your test method:

[source,java]
----
@EnableMockWebServer
@DisplayName("Endpoint Dispatcher Example")
class EndpointDispatcherExampleTest {

    @Test
    @DisplayName("Should handle requests using EndpointAnswerHandler")
    void withEndpointDispatcher(MockWebServer server, URIBuilder uriBuilder) throws IOException, InterruptedException {
        // Configure the dispatcher
        var apiDispatcher = new BaseAllAcceptDispatcher("/api");
        
        // Configure the GET response handler with proper JSON and Content-Type
        apiDispatcher.getGetResult().setResponse(new MockResponse.Builder()
                .addHeader("Content-Type", "application/json")
                .body("{\"data\": \"test\"}")
                .code(HttpServletResponse.SC_OK)
                .build());
                
        // Set the dispatcher on the server
        server.setDispatcher(new CombinedDispatcher(apiDispatcher));

        // Create HttpClient
        HttpClient client = HttpClient.newHttpClient();

        // Create request using the URIBuilder parameter
        HttpRequest request = HttpRequest.newBuilder()
                .uri(uriBuilder.addPathSegments("api", "data").build())
                .GET()
                .build();

        // Send request and verify response
        HttpResponse<String> response = client.send(request,
                HttpResponse.BodyHandlers.ofString());
        assertEquals(200, response.statusCode());
        assertEquals("{\"data\": \"test\"}", response.body());
    }
}
----

=== ModuleDispatcherElement

`ModuleDispatcherElement` enables reusable request handling in `EnableMockWebServer` contexts. It returns an `Optional<MockResponse>` for matching requests.

Example JWKS endpoint dispatcher:

[source,java]
----
/**
 * Handles JWKS file resolution from the mock OAuth server, serving
 * "src/test/resources/token/test-public-key.jwks"
 */
public class JwksResolveDispatcher implements ModuleDispatcherElement {

    /** "/oidc/jwks.json" */
    public static final String LOCAL_PATH = "/oidc/jwks.json";

    @Getter
    @Setter
    private int callCounter = 0;

    @Override
    public Optional<MockResponse> handleGet(@NonNull RecordedRequest request) {
        callCounter++;
        return Optional.of(new MockResponse().addHeader("Content-Type", "application/json")
                .setBody(FileLoaderUtility
                        .toStringUnchecked(FileLoaderUtility.getLoaderForPath(PUBLIC_KEY_JWKS)))
                .setResponseCode(SC_OK));
    }

    @Override
    public String getBaseUrl() {
        return LOCAL_PATH;
    }

    /**
     * Verifies request count
     *
     * @param expected Expected number of requests
     */
    public void assertCallsAnswered(int expected) {
        assertEquals(expected, callCounter);
    }
}
----

Implementation example:

[source,java]
----
@EnableAutoWeld
@EnablePortalConfiguration
@EnableMockWebServer
class TokenParserProducerTest implements ShouldBeNotNull<TokenParserProducer> {

    private final JwksResolveDispatcher jwksResolveDispatcher = new JwksResolveDispatcher();
    private int mockserverPort;

    @BeforeEach
    void setupMockServer(MockWebServer mockWebServer) {
        // Configure the dispatcher
        CombinedDispatcher dispatcher = new CombinedDispatcher().addDispatcher(jwksResolveDispatcher);
        mockWebServer.setDispatcher(dispatcher);
        
        // Setup configuration
        mockserverPort = mockWebServer.getPort();
        configuration.put(VERIFY_SIGNATURE_JWKS_URL,
                "http://localhost:" + mockserverPort + jwksResolveDispatcher.getBaseUrl());
        configuration.update(VERIFY_SIGNATURE_ISSUER, TestTokenProducer.ISSUER);
        configuration.update(VERIFY_SIGNATURE_REFRESH_INTERVAL, "60");
        jwksResolveDispatcher.setCallCounter(0);
    }

    @Test
    void shouldCacheMultipleCalls() {
        jwksResolveDispatcher.assertCallsAnswered(0);
        String token = validSignedJWTWithClaims(PATIENT_ACCESS_TOKEN);
        JWTParser parser = parserProvider.get();

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        // Note: Initial implementation results in 2 calls instead of 1
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);
    }
}
----

=== Manual Server Start

The extension supports manual server start with the `manualStart = true` option. This is useful when you need more control over when and how the server is started:

[source,java]
----
@EnableMockWebServer(manualStart = true)
class MockWebServerManualStartTest {

    private static final CuiLogger LOGGER = new CuiLogger(MockWebServerManualStartTest.class);

    @Test
    @DisplayName("Server should not be started automatically when manualStart=true")
    void shouldNotStartServerAutomatically(MockWebServer server) {
        assertNotNull(server, "Server should be injected");
        assertFalse(server.getStarted(), "Server should not be started automatically");

        // Start the server manually
        try {
            // Configure the dispatcher before starting
            server.setDispatcher(CombinedDispatcher.createAPIDispatcher());
            
            // Start the server
            server.start();
            assertTrue(server.getStarted(), "Server should be started after manual start");

            // Verify server is accessible with timeout
            HttpClient client = HttpClient.newBuilder()
                    .connectTimeout(Duration.ofSeconds(2))
                    .build();

            // Create a proper URIBuilder now that the server is started
            URIBuilder properUriBuilder = URIBuilder.from(server.url("/").url());

            // Use the proper URIBuilder to construct the URI
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(properUriBuilder.addPathSegments("api", "test").build())
                    .timeout(Duration.ofSeconds(2))
                    .GET()
                    .build();
                    
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            assertEquals(200, response.statusCode(), "Should receive OK response");
            LOGGER.info("Successfully received response from manually started server: " + response.body());
            
        } catch (Exception e) {
            LOGGER.error("Failed to start or use server", e);
            fail("Failed to start or use server: " + e.getMessage());
        } finally {
            // Clean up
            try {
                if (server.getStarted()) {
                    server.shutdown();
                }
            } catch (IOException e) {
                // Ignore shutdown errors in tests
            }
        }
    }
}
----

==== Important URIBuilder Precautions with Manual Start

When using `manualStart = true`, you need to be careful with the injected `URIBuilder` parameter:

* Before the server is started, the injected `URIBuilder` is a placeholder that cannot be used to build URIs
* If you try to build a URI from this placeholder, it will throw an `IllegalStateException`
* You must create a proper `URIBuilder` *after* manually starting the server

[source,java]
----
// INCORRECT - Will throw IllegalStateException if server not started
URI uri = uriBuilder.addPathSegment("api").build();

// CORRECT - Create a proper URIBuilder after starting the server
server.start();
URIBuilder properUriBuilder = URIBuilder.from(server.url("/").url());
URI uri = properUriBuilder.addPathSegment("api").build();

----

=== URIBuilder Usage

When building URIs with multiple path segments,
prefer using the `addPathSegments` method instead of chaining multiple `addPathSegment` calls:

[source,java]
----
// RECOMMENDED - Use addPathSegments for multiple path segments
URI uri = uriBuilder.addPathSegments("api", "users", "123").build();

URI uri = uriBuilder.addPathSegment("api").addPathSegment("users").addPathSegment("123").build();
----

=== Parameter Injection

MockWebServerExtension implements ParameterResolver, allowing direct injection of MockWebServer and related parameters into test methods. This is the recommended approach for accessing the server and related components.

See the examples above for how to use parameter injection in your tests.

Supported parameter types:

* `MockWebServer` - The server instance
* `URIBuilder` - A builder for constructing request URIs
* `SSLContext` - The SSL context for HTTPS connections (when HTTPS is enabled)

=== HTTPS Support

When HTTPS is enabled, the extension automatically makes the SSLContext available for parameter injection, simplifying HTTPS testing.

==== Extension-Provided Certificates

The simplest approach is to let the extension generate certificates for you:

[source,java]
----
@EnableMockWebServer(
        useHttps = true
)
@DisplayName("HttpClient HTTPS Test")
class ExtensionProvidedHttpsTest {

    /**
     * Tests a basic HTTPS connection to a default endpoint.
     * This demonstrates the most common use case for HTTPS testing.
     * <p>
     * The SSLContext is directly injected as a parameter using the parameter resolving feature.
     */
    @Test
    @DisplayName("Should successfully connect to HTTPS server with extension-provided certificate")
    void shouldConnectToHttpsServer(MockWebServer server, URIBuilder serverURIBuilder, SSLContext sslContext) 
            throws IOException, InterruptedException {
        // Arrange
        assertNotNull(sslContext, "SSLContext should be injected as a parameter");
        assertNotNull(serverURIBuilder, "URL builder should be injected as a parameter");
        
        // Configure the dispatcher
        server.setDispatcher(CombinedDispatcher.createAPIDispatcher());

        // Verify the URL builder creates HTTPS URLs
        URI uri = serverURIBuilder.build();
        assertEquals("https", uri.getScheme(), "Server URL should use HTTPS");

        // Configure HttpClient with the injected SSLContext
        HttpClient client = HttpClient.newBuilder()
                .sslContext(sslContext)
                .connectTimeout(Duration.ofSeconds(10))
                .build();

        // Act: Make an HTTPS request using the URL builder
        HttpRequest request = HttpRequest.newBuilder()
                .uri(serverURIBuilder.addPathSegments("api", "test").build())
                .GET()
                .build();

        // Assert: Verify successful connection and response
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        assertEquals(200, response.statusCode(), "Should receive 200 OK response");
        assertEquals(EndpointAnswerHandler.RESPONSE_SUCCESSFUL_BODY, response.body(), 
                "Response body should match expected content");
    }
}
----

==== Custom Certificate Provision with @TestProvidedCertificate

For more control over certificate creation, use the `@TestProvidedCertificate` annotation. This approach allows you to provide custom certificates in a flexible way:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/AnnotationProvidedCertificateTest.java[tags=annotation-certificate-example]
----

==== Using a Provider Class

You can also use a separate provider class for better reuse of certificate creation logic:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/CertificateProviderTest.java[tags=provider-class-example]
----

The certificate provider class implementation:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/CertificateProviderTest.java[tags=certificate-provider]
----

==== HTTPS Configuration Options

* `useHttps` - Enable HTTPS support (default: false)
* `@TestProvidedCertificate` - Annotation to specify custom certificate provision
  * `methodName` - Name of the static method that provides certificates
  * `providerClass` - Class that contains the certificate provider method
