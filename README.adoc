= cui-test-mockwebserver-junit5

== Status

image:https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml/badge.svg[Java CI with Maven,link=https://github.com/cuioss/cui-test-mockwebserver-junit5/actions/workflows/maven.yml]
image:http://img.shields.io/:license-apache-blue.svg[License,link=http://www.apache.org/licenses/LICENSE-2.0.html]
image:https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5/badge.svg[Maven Central,link=https://maven-badges.herokuapp.com/maven-central/de.cuioss.test/cui-test-mockwebserver-junit5]

https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5[image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=alert_status[Quality
Gate Status]]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=ncloc[Lines of Code,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]
image:https://sonarcloud.io/api/project_badges/measure?project=cuioss_cui-test-mockwebserver-junit5&metric=coverage[Coverage,link=https://sonarcloud.io/summary/new_code?id=cuioss_cui-test-mockwebserver-junit5]


https://cuioss.github.io/cui-test-mockwebserver-junit5/about.html[Generated Documentation on github-pages]

== What is it?

A junit 5 extension for link:https://github.com/square/okhttp/tree/master/mockwebserver[MockWebServer]
 providing some convenience,
compared to the original.

=== Maven Coordinates

[source,xml]
----
    <dependency>
        <groupId>de.cuioss.test</groupId>
        <artifactId>cui-test-mockwebserver-junit5</artifactId>
    </dependency>
----

== Using MockWebServer

=== Basic usage with Parameter Injection

The recommended approach is to use parameter injection rather than implementing the MockWebServerHolder interface:

[source,java]
----
@EnableMockWebServer
class ParameterResolverTest {

    @Test
    @DisplayName("Should inject MockWebServer instance")
    void shouldInjectMockWebServer(MockWebServer server) {
        assertNotNull(server);
        assertTrue(server.getStarted());
    }

    // Tests for port parameter resolver removed as it's redundant with URIBuilder

    @Test
    @DisplayName("Should inject URIBuilder")
    void shouldInjectUriBuilder(URIBuilder uriBuilder) {
        assertNotNull(uriBuilder);
        assertEquals("http", uriBuilder.build().getScheme());
        assertEquals("/", uriBuilder.getPath());
    }

    // Test for String parameter resolver removed as it's redundant with URIBuilder

    @Test
    @DisplayName("Should inject multiple parameters")
    void shouldInjectMultipleParameters(MockWebServer server, URIBuilder uriBuilder) {
        assertNotNull(server);
        assertTrue(server.getPort() > 0);
        assertEquals(server.getPort(), uriBuilder.getPort());
    }
}
----

=== Migration Guide: From MockWebServerHolder to Annotation-Based Dispatchers

Starting with version 1.1, the `MockWebServerHolder` interface and its `getDispatcher()` method are deprecated and will be removed in a future version. The recommended approach is to use the new annotation-based dispatcher configuration.

==== Before (Deprecated)

[source,java]
----
@EnableMockWebServer
class MyTest implements MockWebServerHolder {

    @Override
    public Dispatcher getDispatcher() {
        return new CombinedDispatcher(new BaseAllAcceptDispatcher("/api"));
    }
    
    @Test
    void testSomething(URIBuilder uriBuilder) {
        // Test code
    }
}
----

==== After (Recommended)

[source,java]
----
@EnableMockWebServer
@ModuleDispatcher // No parameters means look for getModuleDispatcher() method
class MyTest {

    ModuleDispatcherElement getModuleDispatcher() {
        return new BaseAllAcceptDispatcher("/api");
    }
    
    @Test
    void testSomething(URIBuilder uriBuilder) {
        // Test code
    }
}
----

==== Migration Steps

1. Add the `@ModuleDispatcher` annotation to your test class
2. Replace the `getDispatcher()` method with `getModuleDispatcher()` that returns a `ModuleDispatcherElement`
3. If your dispatcher is not a `ModuleDispatcherElement`, wrap it in a `CombinedDispatcher`
4. Remove the `implements MockWebServerHolder` from your class declaration

=== Annotation-Based Dispatchers (New in 1.1)

Starting with version 1.1, you can use the `@ModuleDispatcher` annotation to configure dispatchers for your tests. This approach is recommended over implementing the `MockWebServerHolder` interface, which is now deprecated.

==== Basic Usage with Class Reference

[source,java]
----
@EnableMockWebServer
@ModuleDispatcher(UserApiDispatcher.class)
class SimpleTest {
    
    @Test
    void shouldHandleRequests(MockWebServer server, URIBuilder uriBuilder) throws IOException {
        // The UserApiDispatcher is automatically configured
        // No need to call server.setDispatcher()
        
        // Create HttpClient
        HttpClient client = HttpClient.newHttpClient();
        
        // Create request
        HttpRequest request = HttpRequest.newBuilder()
                .uri(uriBuilder.addPathSegments("api", "users").build())
                .GET()
                .build();
                
        // Send request
        HttpResponse<String> response = client.send(request, 
                HttpResponse.BodyHandlers.ofString());
                
        // Verify response
        assertEquals(200, response.statusCode());
        assertEquals("{\"users\": []}", response.body());
    }
}
----

==== Using a Provider Method

[source,java]
----
@EnableMockWebServer
@ModuleDispatcher(provider = DispatcherFactory.class, providerMethod = "createApiDispatcher")
class FactoryTest {
    
    @Test
    void shouldUseFactoryDispatcher(URIBuilder uriBuilder) {
        // The dispatcher is created by calling DispatcherFactory.createApiDispatcher()
        // ...
    }
}

// Factory class that provides dispatchers
class DispatcherFactory {
    
    // Static factory method
    public static ModuleDispatcherElement createApiDispatcher() {
        return new BaseAllAcceptDispatcher("/api");
    }
}
----

==== Using a Method in the Test Class

[source,java]
----
@EnableMockWebServer
@ModuleDispatcher // No parameters means look for getModuleDispatcher() method
class CustomTest {
    
    // This method will be called to get the dispatcher
    ModuleDispatcherElement getModuleDispatcher() {
        var dispatcher = new BaseAllAcceptDispatcher("/api");
        dispatcher.getGetResult().setResponse(
            new MockResponse.Builder()
                .addHeader("Content-Type", "application/json")
                .body("{\"status\": \"ok\"}")
                .code(200)
                .build());
        return dispatcher;
    }
    
    @Test
    void shouldUseCustomDispatcher(URIBuilder uriBuilder) {
        // The dispatcher is created by calling getModuleDispatcher()
        // ...
    }
}
----

=== ModuleDispatcherElement

`ModuleDispatcherElement` enables reusable request handling in `EnableMockWebServer` contexts. It returns an `Optional<MockResponse>` for matching requests.

The interface requires implementing the following methods:

1. `String getBaseUrl()` - Returns the base URL path that this dispatcher handles
2. `Set<HttpMethodMapper> supportedMethods()` - Returns the set of HTTP methods supported by this dispatcher element
3. HTTP method handlers like `handleGet()`, `handlePost()`, etc. (only for methods returned by `supportedMethods()`)

Example JWKS endpoint dispatcher:

[source,java]
----
/**
 * Handles JWKS file resolution from the mock OAuth server, serving
 * "src/test/resources/token/test-public-key.jwks"
 */
public class JwksResolveDispatcher implements ModuleDispatcherElement {

    /** "/oidc/jwks.json" */
    public static final String LOCAL_PATH = "/oidc/jwks.json";

    @Getter
    @Setter
    private int callCounter = 0;

    @Override
    public Optional<MockResponse> handleGet(@NonNull RecordedRequest request) {
        callCounter++;
        return Optional.of(new MockResponse().addHeader("Content-Type", "application/json")
                .setBody(FileLoaderUtility
                        .toStringUnchecked(FileLoaderUtility.getLoaderForPath(PUBLIC_KEY_JWKS)))
                .setResponseCode(SC_OK));
    }

    @Override
    public String getBaseUrl() {
        return LOCAL_PATH;
    }
    
    @Override
    public @NonNull Set<HttpMethodMapper> supportedMethods() {
        return Set.of(HttpMethodMapper.GET);
    }

    /**
     * Verifies request count
     *
     * @param expected Expected number of requests
     */
    public void assertCallsAnswered(int expected) {
        assertEquals(expected, callCounter);
    }
}
----

Implementation example:

[source,java]
----
@EnableAutoWeld
@EnablePortalConfiguration
@EnableMockWebServer
class TokenParserProducerTest implements ShouldBeNotNull<TokenParserProducer> {

    private final JwksResolveDispatcher jwksResolveDispatcher = new JwksResolveDispatcher();
    private int mockserverPort;

    @BeforeEach
    void setupMockServer(MockWebServer mockWebServer) {
        // Configure the dispatcher
        CombinedDispatcher dispatcher = new CombinedDispatcher().addDispatcher(jwksResolveDispatcher);
        mockWebServer.setDispatcher(dispatcher);
        
        // Setup configuration
        mockserverPort = mockWebServer.getPort();
        configuration.put(VERIFY_SIGNATURE_JWKS_URL,
                "http://localhost:" + mockserverPort + jwksResolveDispatcher.getBaseUrl());
        configuration.update(VERIFY_SIGNATURE_ISSUER, TestTokenProducer.ISSUER);
        configuration.update(VERIFY_SIGNATURE_REFRESH_INTERVAL, "60");
        jwksResolveDispatcher.setCallCounter(0);
    }

    @Test
    void shouldCacheMultipleCalls() {
        jwksResolveDispatcher.assertCallsAnswered(0);
        String token = validSignedJWTWithClaims(PATIENT_ACCESS_TOKEN);
        JWTParser parser = parserProvider.get();

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        // Note: Initial implementation results in 2 calls instead of 1
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);

        for (int i = 0; i < 100; i++) {
            JsonWebToken jsonWebToken = assertDoesNotThrow(() -> ParsedToken.jsonWebTokenFrom(token, parser, LOGGER));
            assertValidJsonWebToken(jsonWebToken, token);
        }
        assertTrue(jwksResolveDispatcher.getCallCounter() < 3);
    }
}
----

=== Manual Server Start

The extension supports manual server start with the `manualStart = true` option. This is useful when you need more control over when and how the server is started:

[source,java]
----
@EnableMockWebServer(manualStart = true)
class MockWebServerManualStartTest {

    private static final CuiLogger LOGGER = new CuiLogger(MockWebServerManualStartTest.class);

    @Test
    @DisplayName("Server should not be started automatically when manualStart=true")
    void shouldNotStartServerAutomatically(MockWebServer server) {
        assertNotNull(server, "Server should be injected");
        assertFalse(server.getStarted(), "Server should not be started automatically");

        // Start the server manually
        try {
            // Configure the dispatcher before starting
            server.setDispatcher(CombinedDispatcher.createAPIDispatcher());
            
            // Start the server
            server.start();
            assertTrue(server.getStarted(), "Server should be started after manual start");

            // Verify server is accessible with timeout
            HttpClient client = HttpClient.newBuilder()
                    .connectTimeout(Duration.ofSeconds(2))
                    .build();

            // Create a proper URIBuilder now that the server is started
            URIBuilder properUriBuilder = URIBuilder.from(server.url("/").url());

            // Use the proper URIBuilder to construct the URI
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(properUriBuilder.addPathSegments("api", "test").build())
                    .timeout(Duration.ofSeconds(2))
                    .GET()
                    .build();
                    
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            assertEquals(200, response.statusCode(), "Should receive OK response");
            LOGGER.info("Successfully received response from manually started server: " + response.body());
            
        } catch (Exception e) {
            LOGGER.error("Failed to start or use server", e);
            fail("Failed to start or use server: " + e.getMessage());
        } finally {
            // Clean up
            try {
                if (server.getStarted()) {
                    server.shutdown();
                }
            } catch (IOException e) {
                // Ignore shutdown errors in tests
            }
        }
    }
}
----

==== Important URIBuilder Precautions with Manual Start

When using `manualStart = true`, you need to be careful with the injected `URIBuilder` parameter:

* Before the server is started, the injected `URIBuilder` is a placeholder that cannot be used to build URIs
* If you try to build a URI from this placeholder, it will throw an `IllegalStateException`
* You must create a proper `URIBuilder` *after* manually starting the server

[source,java]
----
// INCORRECT - Will throw IllegalStateException if server not started
URI uri = uriBuilder.addPathSegment("api").build();

// CORRECT - Create a proper URIBuilder after starting the server
server.start();
URIBuilder properUriBuilder = URIBuilder.from(server.url("/").url());
URI uri = properUriBuilder.addPathSegment("api").build();

----

=== URIBuilder Usage

When building URIs with multiple path segments,
prefer using the `addPathSegments` method instead of chaining multiple `addPathSegment` calls:

[source,java]
----
// RECOMMENDED - Use addPathSegments for multiple path segments
URI uri = uriBuilder.addPathSegments("api", "users", "123").build();

URI uri = uriBuilder.addPathSegment("api").addPathSegment("users").addPathSegment("123").build();
----

=== Parameter Injection

MockWebServerExtension implements ParameterResolver, allowing direct injection of MockWebServer and related parameters into test methods. This is the recommended approach for accessing the server and related components.

See the examples above for how to use parameter injection in your tests.

Supported parameter types:

* `MockWebServer` - The server instance
* `URIBuilder` - A builder for constructing request URIs
* `SSLContext` - The SSL context for HTTPS connections (when HTTPS is enabled)

=== HTTPS Support

When HTTPS is enabled, the extension automatically makes the SSLContext available for parameter injection, simplifying HTTPS testing.

==== Extension-Provided Certificates

The simplest approach is to let the extension generate certificates for you:

[source,java]
----
@EnableMockWebServer(
        useHttps = true
)
@DisplayName("HttpClient HTTPS Test")
class ExtensionProvidedHttpsTest {

    /**
     * Tests a basic HTTPS connection to a default endpoint.
     * This demonstrates the most common use case for HTTPS testing.
     * <p>
     * The SSLContext is directly injected as a parameter using the parameter resolving feature.
     */
    @Test
    @DisplayName("Should successfully connect to HTTPS server with extension-provided certificate")
    void shouldConnectToHttpsServer(MockWebServer server, URIBuilder serverURIBuilder, SSLContext sslContext) 
            throws IOException, InterruptedException {
        // Arrange
        assertNotNull(sslContext, "SSLContext should be injected as a parameter");
        assertNotNull(serverURIBuilder, "URL builder should be injected as a parameter");
        
        // Configure the dispatcher
        server.setDispatcher(CombinedDispatcher.createAPIDispatcher());

        // Verify the URL builder creates HTTPS URLs
        URI uri = serverURIBuilder.build();
        assertEquals("https", uri.getScheme(), "Server URL should use HTTPS");

        // Configure HttpClient with the injected SSLContext
        HttpClient client = HttpClient.newBuilder()
                .sslContext(sslContext)
                .connectTimeout(Duration.ofSeconds(10))
                .build();

        // Act: Make an HTTPS request using the URL builder
        HttpRequest request = HttpRequest.newBuilder()
                .uri(serverURIBuilder.addPathSegments("api", "test").build())
                .GET()
                .build();

        // Assert: Verify successful connection and response
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        assertEquals(200, response.statusCode(), "Should receive 200 OK response");
        assertEquals(EndpointAnswerHandler.RESPONSE_SUCCESSFUL_BODY, response.body(), 
                "Response body should match expected content");
    }
}
----

==== Custom Certificate Provision with @TestProvidedCertificate

For more control over certificate creation, use the `@TestProvidedCertificate` annotation. This approach allows you to provide custom certificates in a flexible way:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/AnnotationProvidedCertificateTest.java[tags=annotation-certificate-example]
----

==== Using a Provider Class

You can also use a separate provider class for better reuse of certificate creation logic:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/CertificateProviderTest.java[tags=provider-class-example]
----

The certificate provider class implementation:

[source,java]
----
include::src/test/java/de/cuioss/test/mockwebserver/https/CertificateProviderTest.java[tags=certificate-provider]
----

==== HTTPS Configuration Options

* `useHttps` - Enable HTTPS support (default: false)
* `@TestProvidedCertificate` - Annotation to specify custom certificate provision
  * `methodName` - Name of the static method that provides certificates
  * `providerClass` - Class that contains the certificate provider method
